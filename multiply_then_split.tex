
Principles: 

* naive gpu algorithm is fast enough
* naive gpu algorithm can be faster than
a ``clever'' cpu algorithm with better complexity

%* comment on the general problem of multiply then split
%* TODO: rephrase everything in terms of the general problem, without 
%reference to delta_1

\begin{cxt}
	\label{cxt:mult:split}
	Let \(\Delta \in S = k[x_{1}, \ldots, x_{n}]\)
	be a homogeneous
	polynomial of degree \(D\).
	In algorithms, we will sometimes conflate \(\Delta\) 
	with a list containing all its terms.
	For \(d\) an integer,
	and let \(S_{d}\) denote the homogeneous polynomials of degree \(d\).
	The dimension of \(S_{d}\) is then \(\binom{n+d-1}{n-1}\).
	Thus, the number of terms of \(\Delta\) is bounded 
	above by \(\binom{n+D-1}{n-1}\).
	We let \(M_{d}\) denote a list (in lexographical order)
	of the monomial basis of \(S_{d}\).
	Let \(d^{\prime} \colonequals \frac{d+D-n-1}{p}\).
	Then 
	We wish to have an algorithm that calculates the matrix of
	the linear operator
	\begin{align*}
		\theta : S_{d} &\longrightarrow S_{d^{\prime}} \\
		g &\longmapsto u(\Delta g)
	.\end{align*}
\end{cxt}

\begin{rmk}
	Note that if  \(d^{\prime} = \frac{d+D-p(n-1)}{p}\)
	is not an integer, \(\theta\) is the zero map
	and ther is nothing more to do.
	
	If \(\Delta = \Delta_{1}(f^{p-1})\) and \(d = n(p-1)\),
	then \(d^{\prime} = d\) and \(\theta\) is
	represented by
	a square matrix.
\end{rmk}

\begin{defn}
	Let \(m\) be a monomial in \(S\). 
	Then we say that \(m\) \textbf{matches}
	with another monomial \(m^{\prime}\) 
	if the monomial \(mm^{\prime}\) is
	not killed by \(u\).
\end{defn}

In the case of calculating the quasi-\(F\)-split height of a Calabi-Yau
hypersurface,
we have \(d = n(p-1)\) and \(D = np(p-1)\).

Notes for complexity calculations:

TODO: change the algorithms to reflect that the input and output space
might not be the same vector space in general.

\subsection{The Naive Algorithm}

\begin{algorithm}[H]
    \caption{Matrix of $\theta$: Trivial Algorithm}
    \label{alg:matrix:trivial}
    \begin{algorithmic}[1]
    \State \textbf{Input}: $\Delta, M_{d}, M_{d^{\prime}}, p$
    \State \textbf{Output}: $length(M_{d^{\prime}}) \times length(M_{d})$ 
	matrix representing $\theta$
    \State mat $\gets zeros(length(M_{d^{\prime}}), length(M_{d}))$
    \For{$m \in M_{d}$}
	    \State $c \gets indexof(m, M _{d})$
        \For{$\delta \in \Delta$}
            \If{$(exponents(\delta) .+ exponents(m)) .\% p =[p-1, \dots, p-1]$} 
			\State res $\gets (exponents(\delta) + exponents(m) - (p-1, \ldots, p-1)) / p$
				\State $r \gets indexof(\text{res},M_{d^{\prime}})$
                \State $\text{mat}[r, c] += coeff(\delta)$
            \EndIf
        \EndFor
    \EndFor
    \State \Return mat
    \end{algorithmic}
\end{algorithm}

In this algorithm, we iterate through the monomials $m \in M_{d}$, each corresponding to a column in the
resulting matrix. For each monomial, we search for terms that match $\delta \in \Delta$, apply $u$ to their product $\delta u$, and 
get the lexographical index of the result to find which row to add to.

Since $length(M_{d}) = \binom{n + d - 1}{n - 1}$ and 
$length(\Delta) = \binom{n + D - 1}{n - 1}$, the matrix can be generated in 
$O(\binom{n + d - 1}{n - 1}\binom{n + D - 1}{n + d - 1})$ operations. 
This can be
seen from the nested loops, assuming that integer arithmetic operations are constant time.
In the case of the quasi-\(F\)-split height of a K3 surface, 
this becomes
\(O(\binom{np - 1}{n-1}\binom{n(p^2 - p + 1)}{n-1})\).

In practice, the majority of the combinations of terms of $\Delta$ and $M_{d}$ don't match. This means in
Algorithm \ref{alg:matrix:trivial}, much of our runtime is wasted on checking for whether terms match. 
However, we emphasize that this algorithm, if implemented in parallel on the GPU, is indeed
fast enough to not be a bottleneck in practice.

\subsection{Modified Merge-based Algorithm}

To find the matrix of \(\theta\), mathematically
speaking we must first multiply by \(\Delta_{1}(f)\) 
and then apply the map \(u\).
Our first observation is that naively 
multiplying and then applying \(u\) 
as in algorithm \ref{alg:naive:u}
does a lot of unnecessary work.
In particular, any term in the 
product \(\Delta_{1}(f)a\) which 
is not congruent to 
\((p-1, \ldots, p-1) \mod p\)
is not needed. 
Even if \(a\) is a monomial, giving a linear
algoritm for multiplication, using naive
multiplication stores a lot of unnecessary terms
in memory.
Here, we give an algorithm that calculates
the matrix of \(\theta\) by only
using such terms.
We start with an elementary fact.

\begin{lem}
	\label{lem:tuples:modp}
	Let \(\underbar{a} = (a_{1}, \ldots, a_{n}),
	\underbar{b} = (b_{1}, \ldots, b_{n})\)
	be in \(\{0, \ldots, p-1\}^{n} \ins \mathbb{Z}^{n}\).

	Then \(\underbar{a} + \underbar{b} = 
	(p-1, \ldots, p-1) \mod p\)
	if and only if 
	\(\underbar{a} + \underbar{b} = 
	(p-1, \ldots, p-1)\).
\end{lem}

\begin{proof}
	Each coordinate has \(a_{i} + b_{i} \leq 2(p-1) = 2p-2\).
\end{proof}


\begin{cor}
	Let \(\underbar{a}\) be as above.
	Let \(\underbar{x}^{\underbar{a}}\)
	denote \(x_{1}^{a_{1}} \ldots x_{n}^{a_{n}}\).
	Then there exists a unique
	match \(m(\underbar{a}) \in \{0, \ldots, p-1\}^{n}\) 
\end{cor}

\begin{proof}
	\(m(\underbar{a}) = 
	(p-1, \ldots, p-1) - \underbar{a}\).
	The claim follows from 
	\ref{lem:tuples:modp}.
\end{proof}

Essentially, this corollary says that
when we consider arbitrary monomials \(M\),
when we consider its exponent vector 
mod \(p\), it has a unique
match mod \(p\).
However, we have even more:

\begin{cor}
	\label{cor:match:order}
	Let \(\leq_{lex}\) denote the 
	lexographical ordering.
	If \(\underbar{a} \leq_{lex} \underbar{b}\),
	then 
	\(m(\underbar{b}) \leq_{lex} m(\underbar{a})\)
\end{cor}

\begin{proof}
	Follows from the definition of lexographical
	ordering.
\end{proof}

The previous two corollaries justify
the following algorithm.

\begin{algorithm}
\caption{Multiply than split: merge-based algorithm}
\label{alg:theta:merge}
\begin{algorithmic}[1]
\State \textbf{Inputs:} \(\Delta, M_{d}, M_{d^{\prime}}, p\)
\State mat \(\gets zeros(length(M), length(M))\) 
\State \(L \gets exponents(\Delta) .\% p\) 
\State \(R \gets exponents(M_{d}) .\% p\)
\State sort both  \(L\) and \(R\) 
\State \(\Delta^{\prime}, M^{\prime} \gets \)permute \(\Delta\) and \(M\) by the sort permutations as \(L\) and \(R\).
\State \(l \gets 1, r \gets legnth(R)\)
\While{\(1 \leq R \&\& l \leq length(L)\)}
	\State cmp \(\gets L[l] + R[r] - (p-1, \ldots, p-1)\) 
	\If{cmp < 0}
	    \State \(l \gets l + 1\) 
	\ElsIf{0 < cmp}
	    \State \(r \gets r - 1\)
    \ElsIf{0 == cmp}
        \State matchr \(\gets R[r]\) 
        \State numLmatches \(\gets\) the number of adjacent entries in \(L\) which are equal to \(L[l]\) 
        \While{\(R[r] == \) matchr \(\&\& 1 \leq r\)}
		    \For{\(ll \in (l, l+1, \ldots, l+\text{numLmatches})\)}
                \State res \(\gets (exponents(\Delta^{\prime}[ll]) .+ exponents(M^{\prime}[r]) .- (p-1, \ldots, p-1)) ./ p\) 
                \State coeff \(\gets coeff(\Delta^{\prime}[ll])\)
                \State \(col \gets indexof(M^{\prime}[r],M_{d})\)
                \State \(row \gets indexof(\text{res},M_{d^{\prime}})\)
                \State \(\text{mat}[row,col] += coeff\) 
            \EndFor
            \State \(r \gets r - 1\)
        \EndWhile     
        \State \(l \gets l + \text{numLmatches} - 1\) 
    \EndIf
\EndWhile
\State \Return mat
\end{algorithmic}
\end{algorithm}

%\begin{alg}
%
%\begin{lstlisting}
%
%delta1 = terms of delta1
%mons = all homogeneous monomials
%nMons = length(mons)
%
%answer := zeros(nMons,nMons)
%L := delta1 .% p
%R := M .% p
%
%sort both L and R (mod p)
%sort delta1 and M according to the same permutation
%
%l := 1, r := length(R)
%
%while 1 <= r && l <= length(R)
%    cmp := L[l] + R[r] - (p-1, ..., p-1)
%    switch cmp
%    case cmp < 0
%        l += 1
%    case 0 < cmp
%        r -= 1
%    case cmp == 0
%        matchr := R[r]
%        numLmatches := (the number of 
%            adjacent entries in L that are equal to L[l])
%        while R[r] == matchr
%            for ll in l:l+numLmatches
%
%                Extract delta1[ll] and its 
%                corresponding coefficient, as well as M[r]
%
%                Apply u to the product of the resulting monomials
%
%                Add this term to the correct entry of answer
%            end
%        end
%    end	
%end		
%
%\end{lstlisting}
%\end{alg}

Note that the inner while loops account for the fact that
after modding by \(p\), one does not expect 
either array to have unique keys.
The algorithm is justified by the previous corollaries.

In practice, instead of sorting the arrays in place, 
we use a method like julia's ``sortperm''
%TODO: code font
to get the sort permutation.

We also may use the kronecker substitution to make
the comparisons and additions use machine integers
rather than vectors.
In practice, this speeds the algorithm up a lot.

* complexity analysis
n = length L, m = length R
we need n + m + n log n + m log m operations.
Thus, the algorithm is big o of max(n log n, m log m),
and in practice the \(\Delta_{1}\) length
usually dominates.
TODO: state the complexity results in terms of the size of f

%In what follows, when we put a dot (\(.\))
%before an operation, that denotes
%componentwise application
%of that operation, similar to Julia syntax.

\subsection{Algorithm based on Generating weak integer compositions}

	Let \(M\) be a lexographically-ordered array containing the terms $m$ of the monomial basis of
	homogeneous polynomials of degree
	\(n*(p-1)\). Let $M_m$ denote the index of $m$ in $M$. Let $coeff(t)$ and $exps(t)$ denote the coefficient of monomial $t$ and exponent vector of $t$ respectively.

\begin{defn}
    $generateMatchingMonomials(\delta, p, M)$ produces a set of monomials $m \in M$ that match with $\delta$
\end{defn}

This function and its implementation are best explained with an example.

\begin{ex}
    Let $p = 5$, and $\delta$ be a monomial with degree sequence $[21, 16, 21, 22]$, where $a$ is some arbitrary coefficient. This is a term that may
    result from the computation of $\Delta_1(f^{p - 1})$ for a quartic K3 surface $f$ over $\mathbb{F}_5$. In this case, $M$ is an array
    of all possible $4$-variate monomials with homogeneous degree $16$. From [21, 16, 21, 22] we add [3, 3, 3, 2] to obtain [24, 19, 24, 24], which
    has all elements congruent to $p-1 \mod p$. Because our monomials are homogeneous of degree $16$, and
    we have only added $3 + 3 + 3 + 2 = 11$ to the degree sequence of $\delta$, we still have $16 - 11 = 5$ more to add.
    To maintain congruence to $p-1 \mod p$, we must add all $5$ to one select variable. With 4 variables to choose from, doing this gives the
    matching monomials $\{[8, 3, 3, 2], [3, 8, 3, 2], [3, 3, 8, 2], [3, 3, 3, 7]\}$.
\end{ex}

\begin{thm}
    generateMatchingMonomials() correctly generates all matching monomials (Should I give a full algorithm for the implementation and why each step works, or can I just remove this Theorem and leave it to the reader? The proof is just a bunch of number crunching which I have the components of commented out at the bottom of this file)
\end{thm}

With this, we have a faster version of our trivial algorithm:

\begin{algorithm}[H]
    \caption{Matrix of $\theta$: WICS Algorithm}
    \label{alg:matrix:WICS}
    \begin{algorithmic}[1]
    \State \textbf{Input}: $\Delta, M_{d}, M_{d^{\prime}}, p$
    \State \textbf{Output}: $length(M_{d^{\prime}}) \times length(M_{d})$ matrix representing $\theta$
    \State mat $\gets zeros(length(M_{d^{\prime}}), length(M_{d}))$
    \For{$\delta \in \Delta$}
        \State mons $\gets generateMatchingMonomials(\delta, p, M_{d})$
        \For{$m \in mons$}
		    \State $c \gets indexof(m,M_{d})$
			\State res $\gets (exponents(\delta) + exponents(m) - (p-1, \ldots, p-1)) / p$
			\State $r \gets indexof(\text{res},M_{d^{\prime}})$
            \State $\text{mat}[r, c] += coeff(\delta)$
        \EndFor
    \EndFor
    \State \Return mat
    \end{algorithmic}
\end{algorithm}

Again, letting $x = len(M)$ and $y = len(\Delta)$, this algorithm generates the matrix in $O(y)$ operations. The number of matching monomials each term $\delta$ has is bounded above by $\binom{\lfloor \frac{n(p - 1)}{p} \rfloor + n - 1}{n}$ (I have a proof but requires me to explain details of generateMatchingMonomials()), which is effectively constant for all $n$ and $p$ computable in the near future.

TODO: state the complexity stuff in terms of the size of f


%\begin{lstlisting}
%	
%	
%	\(answer \colonequals []\)
%	\(L \colonequals \Delta .\% p\) 
%	and \(R \colonequals M .\% p\).
%
%	Sort both \(L\) and \(R\) mod \(p\).
%	Sort \(\Delta\) and \(M\) according to the 
%	same permutation.
%
%	Let \(\ell \colonequals 1, r \colonequals \text{length}(R)\)
%
%	while \(1 \leq r \&\& l \leq \text{length}(L)\)
%
%	--- \(cmp \colonequals L[\ell] + R[r] - (p-1, \ldots, p-1)\)
%
%	--- switch \(cmp\)
%
%	--- --- case  \(cmp < 0\) 
%
%	--- --- --- \(l += 1\) 
%
%	--- --- case \(0 < cmp\) 
%
%	--- --- --- \(r -= 1\) 
%
%	--- --- case \(cmp == 0\) 
%
%	--- --- --- \(matchr \colonequals R[r]\) 
%
%    --- --- --- \(numLmatches \colonequals \) the number of
%	adjacent entrices in \(L\) that are equal to \(L[\ell]\)
%
%	--- --- --- while \(R[r] == matchr\) 
%
%	--- --- --- --- for \(\ell\ell\) in \(\ell\) to \(\ell\) + numLmatches
%
%	--- --- --- --- --- Extract \(\Delta[\ell\ell]\) 
%	and its corresponding coeffient,
%	as well as \(M[r]\)
%
%	--- --- --- --- --- Apply \(u\) to the product
%	of the resulting monomials
%
%	--- --- --- --- --- add this term to \(answer\)
%
%	--- --- --- ---  end for
%
%	--- --- --- --- \(r += 1\) 
%
%	--- --- --- end while
%
%	--- --- --- \(l += numLmatches\) 
%	
%	--- end switch
%
%	end while
%
%\end{lstlisting}



%* picture


% Given $d$ and $p$, we want to add to the coordinates of $d$ until we get some vector $d' \equiv (p - 1, \dots, p - 1) \mod p$. Because $d$ is a term of $\Delta_{1}(f ^ {p - 1})$, the sum of the coordinates of $d$ is $n \cdot (p - 1) \cdot p \equiv 0 \mod p$. Since $d' \equiv (p - 1, \dots, p - 1) \mod p$, the sum of the coordinates of $d'$ is congruent to $n \cdot (p - 1) \equiv -n \mod p$. This means that we will always add $-n \mod p$ to the coordinates of $d$ to get $d'$, and since $m \in M$ has homogeneous degree $n \cdot (p - 1) \equiv -n \mod p$, we have some multiple of $p$ to add to the coordinates of $d'$ to get a term of $\Delta_{1}(f ^ {p - 1})$. Let $m' = d' - d$: this is the foundation of the "relevant" monomial (sum of coordinates of $m'$ is congruent to $-n \mod p$). To actually get an element $m \in M$, we need to add a multiple of $p$ to each coordinate (probably needs a lemma). Since we need to add to $sum(d') \equiv -n \mod p$ from $sum(m') \equiv -n \mod p$, we arrive at the problem of adding $\frac{n * (p - 1) - c}{p}$ $p$'s to $m'$, which can be solved using weak integer compositions.








