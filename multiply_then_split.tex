
\subsection{The Naive Algorithm}

\subsection{Modified Merge-based Algorithm}

To find the matrix of \(\theta\), mathematically
speaking we must first multiply by \(\Delta_{1}(f)\) 
and then apply the map \(u\).
Our first observation is that naively 
multiplying and then applying \(u\) 
as in algorithm \ref{alg:naive:u}
does a lot of unnecessary work.
In particular, any term in the 
product \(\Delta_{1}(f)a\) which 
is not congruent to 
\((p-1, \ldots, p-1) \mod p\)
is not needed. 
Even if \(a\) is a monomial, giving a linear
algoritm for multiplication, using naive
multiplication stores a lot of unnecessary terms
in memory.
Here, we give an algorithm that calculates
the matrix of \(\theta\) by only
using such terms.
We start with an elementary fact.

\begin{lem}
	\label{lem:tuples:modp}
	Let \(\underbar{a} = (a_{1}, \ldots, a_{n}),
	\underbar{b} = (b_{1}, \ldots, b_{n})\)
	be in \(\{0, \ldots, p-1\}^{n} \ins \mathbb{Z}^{n}\).

	Then \(\underbar{a} + \underbar{b} = 
	(p-1, \ldots, p-1) \mod p\)
	if and only if 
	\(\underbar{a} + \underbar{b} = 
	(p-1, \ldots, p-1)\).
\end{lem}

\begin{proof}
	Each coordinate has \(a_{i} + b_{i} \leq 2(p-1) = 2p-2\).
\end{proof}

\begin{defn}
	Let \(m\) be a monomial in \(S\). 
	Then we say that \(m\) \textit{matches}
	with another monomial \(m^{\prime}\) 
	if the monomial \(mm^{\prime}\) is
	not killed by \(u\).
\end{defn}

\begin{cor}
	Let \(\underbar{a}\) be as above.
	Let \(\underbar{x}^{\underbar{a}}\)
	denote \(x_{1}^{a_{1}} \ldots x_{n}^{a_{n}}\).
	Then there exists a unique
	match \(m(\underbar{a}) \in \{0, \ldots, p-1\}^{n}\) 
\end{cor}

\begin{proof}
	\(m(\underbar{a}) = 
	(p-1, \ldots, p-1) - \underbar{a}\).
	The claim follows from 
	\ref{lem:tuples:modp}.
\end{proof}

Essentially, this corollary says that
when we consider arbitrary monomials \(M\),
when we consider its exponent vector 
mod \(p\), it has a unique
match mod \(p\).
However, we have even more:

\begin{cor}
	\label{cor:match:order}
	Let \(\leq_{lex}\) denote the 
	lexographical ordering.
	If \(\underbar{a} \leq_{lex} \underbar{b}\),
	then 
	\(m(\underbar{b}) \leq_{lex} m(\underbar{a})\)
\end{cor}

\begin{proof}
	Follows from the definition of lexographical
	ordering.
\end{proof}

The previous two corollaries justify
the following algorithm.

\begin{cxt}
	Let \(f \in S\) be a homogeneous
	polynomial of degree \(n\).
	Let \(\Delta\) be an array containing the 
	terms $\delta$ of \(\Delta_{1}(f^{p-1})\).
	Let \(M\) be a lexographically-ordered array containing the terms $m$ of the monomial basis of
	homogeneous polynomials of degree
	\(n*(p-1)\). Let $M_m$ denote the index of $m$ in $M$. Let $coeff(t)$ and $exps(t)$ denote the coefficient of monomial $t$ and exponent vector of $t$ respectively.
\end{cxt}

In what follows, when we put a dot (\(.\))
before an operation, that denotes
componentwise application
of that operation, similar to Julia syntax.

\begin{algorithm}[H]
    \caption{Matrix of $\theta$: Trivial Algorithm}
    \label{alg:matrix:trivial}
    \begin{algorithmic}[1]
    \State \textbf{Input}: $\Delta, M, p$
    \State \textbf{Output}: $len(M) \times len(M)$ matrix representing $\theta$
    \State mat $\gets zeros(len(M), len(M))$
    \For{$m \in M$}
        \State $c \gets M_{m}$
        \For{$\delta \in \Delta$}
            \If{$(exps(\delta) .+ exps(m)) .\% p =[p-1, \dots, p-1]$} \Comment{Check for match}
                \State res $\gets u(exps(\delta m))$
                \State $r \gets M_{res}$
                \State mat $[r, c] += coeff(\delta)$
            \EndIf
        \EndFor
    \EndFor
    \State \Return mat
    \end{algorithmic}
\end{algorithm}

In this algorithm, we iterate through the monomials $m \in M$, each corresponding to a column in the
resulting matrix. For each monomial, we search for matching terms $\delta \in \Delta$, apply $u$ to their product $\delta u$, and 
get the lexographical index of the result to find which row to add to.

Letting $x = len(M)$ and $y = len(\Delta)$, the matrix can be generated in $O(xy)$ operations. This can easily be
seen from the nested loop, and that all of the operations within the loop are constant.

Observe that the majority of the $xy$ combinations of terms of $\Delta$ and $M$ don't match. This means in
Algorithm 5, much of our runtime is wasted on checking for whether our terms match. With this in mind:

\begin{defn}
    $generateMatchingMonomials(\delta, p, M)$ produces a set of monomials $m \in M$ that match with $\delta$
\end{defn}

This function and its implementation are best explained with an example.

\begin{ex}
    Let $p = 5$, and $\delta$ be a monomial with degree sequence $[21, 16, 21, 22]$, where $a$ is some arbitrary coefficient. This is a term that may
    result from the computation of $\Delta_1(f^{p - 1})$ for a quartic K3 surface $f$ over $\mathbb{F}_5$. In this case, $M$ is an array
    of all possible $4$-variate monomials with homogeneous degree $16$. From [21, 16, 21, 22] we add [3, 3, 3, 2] to obtain [24, 19, 24, 24], which
    has all elements congruent to $p-1 \mod p$. Because our monomials are homogeneous of degree $16$, and
    we have only added $3 + 3 + 3 + 2 = 11$ to the degree sequence of $\delta$, we still have $16 - 11 = 5$ more to add.
    To maintain congruence to $p-1 \mod p$, we must add all $5$ to one select variable. With 4 variables to choose from, doing this gives the
    matching monomials $\{[8, 3, 3, 2], [3, 8, 3, 2], [3, 3, 8, 2], [3, 3, 3, 7]\}$.
\end{ex}

\begin{thm}
    generateMatchingMonomials() correctly generates all matching monomials (Should I give a full algorithm for the implementation and why each step works, or can I just remove this Theorem and leave it to the reader? The proof is just a bunch of number crunching which I have the components of commented out at the bottom of this file)
\end{thm}

With this, we have a faster version of our trivial algorithm:

\begin{algorithm}[H]
    \caption{Matrix of $\theta$: WICS Algorithm}
    \label{alg:matrix:WICS}
    \begin{algorithmic}[1]
    \State \textbf{Input}: $\Delta, M, p$
    \State \textbf{Output}: $len(M) \times len(M)$ matrix representing $\theta$
    \State mat $\gets zeros(len(M), len(M))$
    \For{$\delta \in \Delta$}
        \State mons $\gets generateMatchingMonomials(\delta, p, M)$
        \For{$m \in mons$}
            \State $c \gets M_m$
            \State res $\gets u(exps(\delta m))$
            \State $r \gets M_{res}$
            \State mat $[r, c] += coeff(\delta)$
        \EndFor
    \EndFor
    \State \Return mat
    \end{algorithmic}
\end{algorithm}

Again, letting $x = len(M)$ and $y = len(\Delta)$, this algorithm generates the matrix in $O(y)$ operations. The number of matching monomials each term $\delta$ has is bounded above by $\binom{\lfloor \frac{n(p - 1)}{p} \rfloor + n - 1}{n}$ (I have a proof but requires me to explain details of generateMatchingMonomials()), which is effectively constant for all $n$ and $p$ computable in the near future.


\begin{alg}

\begin{lstlisting}

delta1 = terms of delta1
mons = all homogeneous monomials
nMons = length(mons)

answer := zeros(nMons,nMons)
L := delta1 .% p
R := M .% p

sort both L and R (mod p)
sort delta1 and M according to the same permutation

l := 1, r := length(R)

while 1 <= r && l <= length(R)
    cmp := L[l] + R[r] - (p-1, ..., p-1)
    switch cmp
    case cmp < 0
        l += 1
    case 0 < cmp
        r -= 1
    case cmp == 0
        matchr := R[r]
        numLmatches := (the number of 
            adjacent entries in L that are equal to L[l])
        while R[r] == matchr
            for ll in l:l+numLmatches

                Extract delta1[ll] and its 
                corresponding coefficient, as well as M[r]

                Apply u to the product of the resulting monomials

                Add this term to the correct entry of answer
            end
        end
    end	
end		

\end{lstlisting}


%\begin{lstlisting}
%	
%	
%	\(answer \colonequals []\)
%	\(L \colonequals \Delta .\% p\) 
%	and \(R \colonequals M .\% p\).
%
%	Sort both \(L\) and \(R\) mod \(p\).
%	Sort \(\Delta\) and \(M\) according to the 
%	same permutation.
%
%	Let \(\ell \colonequals 1, r \colonequals \text{length}(R)\)
%
%	while \(1 \leq r \&\& l \leq \text{length}(L)\)
%
%	--- \(cmp \colonequals L[\ell] + R[r] - (p-1, \ldots, p-1)\)
%
%	--- switch \(cmp\)
%
%	--- --- case  \(cmp < 0\) 
%
%	--- --- --- \(l += 1\) 
%
%	--- --- case \(0 < cmp\) 
%
%	--- --- --- \(r -= 1\) 
%
%	--- --- case \(cmp == 0\) 
%
%	--- --- --- \(matchr \colonequals R[r]\) 
%
%    --- --- --- \(numLmatches \colonequals \) the number of
%	adjacent entrices in \(L\) that are equal to \(L[\ell]\)
%
%	--- --- --- while \(R[r] == matchr\) 
%
%	--- --- --- --- for \(\ell\ell\) in \(\ell\) to \(\ell\) + numLmatches
%
%	--- --- --- --- --- Extract \(\Delta[\ell\ell]\) 
%	and its corresponding coeffient,
%	as well as \(M[r]\)
%
%	--- --- --- --- --- Apply \(u\) to the product
%	of the resulting monomials
%
%	--- --- --- --- --- add this term to \(answer\)
%
%	--- --- --- ---  end for
%
%	--- --- --- --- \(r += 1\) 
%
%	--- --- --- end while
%
%	--- --- --- \(l += numLmatches\) 
%	
%	--- end switch
%
%	end while
%
%\end{lstlisting}
\end{alg}

Note that the inner while loops account for the fact that
after modding by \(p\), one does not expect 
either array to have unique keys.
The algorithm is justified by the previous corollaries.

In practice, instead of sorting the arrays in place, 
we use a method like julia's ``sortperm''
%TODO: code font
to get the sort permutation.

We also may use the kronecker substitution to make
the comparisons and additions use machine integers
rather than vectors.
In practice, this speeds the algorithm up a lot.

* complexity analysis
n = length L, m = length R
we need n + m + n log n + m log m operations.
Thus, the algorithm is big o of max(n log n, m log m),
and in practice the \(\Delta_{1}\) length
usually dominates.

* picture

\subsection{Algorithm based on Generating weak integer compositions}

% Given $d$ and $p$, we want to add to the coordinates of $d$ until we get some vector $d' \equiv (p - 1, \dots, p - 1) \mod p$. Because $d$ is a term of $\Delta_{1}(f ^ {p - 1})$, the sum of the coordinates of $d$ is $n \cdot (p - 1) \cdot p \equiv 0 \mod p$. Since $d' \equiv (p - 1, \dots, p - 1) \mod p$, the sum of the coordinates of $d'$ is congruent to $n \cdot (p - 1) \equiv -n \mod p$. This means that we will always add $-n \mod p$ to the coordinates of $d$ to get $d'$, and since $m \in M$ has homogeneous degree $n \cdot (p - 1) \equiv -n \mod p$, we have some multiple of $p$ to add to the coordinates of $d'$ to get a term of $\Delta_{1}(f ^ {p - 1})$. Let $m' = d' - d$: this is the foundation of the "relevant" monomial (sum of coordinates of $m'$ is congruent to $-n \mod p$). To actually get an element $m \in M$, we need to add a multiple of $p$ to each coordinate (probably needs a lemma). Since we need to add to $sum(d') \equiv -n \mod p$ from $sum(m') \equiv -n \mod p$, we arrive at the problem of adding $\frac{n * (p - 1) - c}{p}$ $p$'s to $m'$, which can be solved using weak integer compositions.








