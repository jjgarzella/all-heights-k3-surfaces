
To find the matrix of \(\theta\), mathematically
speaking we must first multiply by \(\Delta_{1}(f)\) 
and then apply the map \(u\).
Our first observation is that naively 
multiplying and then applying \(u\) 
as in algorithm \ref{alg:naive:u}
does a lot of unnecessary work.
In particular, any term in the 
product \(\Delta_{1}(f)a\) which 
is not congruent to 
\((p-1, \ldots, p-1) \mod p\)
is not needed. 
Even if \(a\) is a monomial, giving a linear
algoritm for multiplication, using naive
multiplication stores a lot of unnecessary terms
in memory.
Here, we give an algorithm that calculates
the matrix of \(\theta\) by only
using such terms.
We start with an elementary fact.

\begin{lem}
	\label{lem:tuples:modp}
	Let \(\underbar{a} = (a_{1}, \ldots, a_{n}),
	\underbar{b} = (b_{1}, \ldots, b_{n})\)
	be in \(\{0, \ldots, p-1\}^{n} \ins \mathbb{Z}^{n}\).

	Then \(\underbar{a} + \underbar{b} = 
	(p-1, \ldots, p-1) \mod p\)
	if and only if 
	\(\underbar{a} + \underbar{b} = 
	(p-1, \ldots, p-1)\).
\end{lem}

\begin{proof}
	Each coordinate has \(a_{i} + b_{i} \leq 2(p-1) = 2p-2\).
\end{proof}

\begin{defn}
	Let \(M\) be a monomial in \(S\). 
	Then we say that \(M\) \textit{matches}
	with another monomial \(M^{\prime}\) 
	if the monomial \(MM^{\prime}\) is
	not killed by \(u\).
\end{defn}

\begin{cor}
	Let \(\underbar{a}\) be as above.
	Let \(\underbar{x}^{\underbar{a}}\)
	denote \(x_{1}^{a_{1}} \ldots x_{n}^{a_{n}}\).
	Then there exists a unique
	match \(m(\underbar{a}) \in \{0, \ldots, p-1\}^{n}\) 
\end{cor}

\begin{proof}
	\(m(\underbar{a}) = 
	(p-1, \ldots, p-1) - \underbar{a}\).
	The claim follows from 
	\ref{lem:tuples:modp}.
\end{proof}

Essentially, this corollary says that
when we consider arbitrary monomials \(M\),
when we consider its exponent vector 
mod \(p\), it has a unique
match mod \(p\).
However, we have even more:

\begin{cor}
	\label{cor:match:order}
	Let \(\leq_{lex}\) denote the 
	lexographical ordering.
	If \(\underbar{a} \leq_{lex} \underbar{b}\),
	then 
	\(m(\underbar{b}) \leq_{lex} m(\underbar{a})\)
\end{cor}

\begin{proof}
	Follows from the definition of lexographical
	ordering.
\end{proof}

The previous two corollaries justify
the following algorithm.

\begin{cxt}
	Let \(f \in S\) be a homogeneous
	polynomial of degree \(n\).
	Let \(\Delta\) be an array containing the 
	exponent vectors of \(\Delta_{1}(f^{p-1})\).
	Let \(M\) be an array containing the exponent
	vectors of the monomial basis of
	homogeneous polynomials of degree
	\(n*(p-1)\).
\end{cxt}

In what follows, when we put a dot (\(.\))
before an operation, that denotes
componentwise application
of that operation, similar to Julia syntax.

\begin{alg}

\begin{lstlisting}

delta1 = terms of delta1
mons = all homogeneous monomials
nMons = length(mons)

answer := zeros(nMons,nMons)
L := delta1 .% p
R := M .% p

sort both L and R (mod p)
sort delta1 and M according to the same permutation

l := 1, r := length(R)

while 1 <= r && l <= length(R)
    cmp := L[l] + R[r] - (p-1, ..., p-1)
    switch cmp
    case cmp < 0
        l += 1
    case 0 < cmp
        r -= 1
    case cmp == 0
        matchr := R[r]
        numLmatches := (the number of 
            adjacent entries in L that are equal to L[l])
        while R[r] == matchr
            for ll in l:l+numLmatches

                Extract delta1[ll] and its 
                corresponding coefficient, as well as M[r]

                Apply u to the product of the resulting monomials

                Add this term to the correct entry of answer
            end
        end
    end	
end		

\end{lstlisting}


%\begin{lstlisting}
%	
%	
%	\(answer \colonequals []\)
%	\(L \colonequals \Delta .\% p\) 
%	and \(R \colonequals M .\% p\).
%
%	Sort both \(L\) and \(R\) mod \(p\).
%	Sort \(\Delta\) and \(M\) according to the 
%	same permutation.
%
%	Let \(\ell \colonequals 1, r \colonequals \text{length}(R)\)
%
%	while \(1 \leq r \&\& l \leq \text{length}(L)\)
%
%	--- \(cmp \colonequals L[\ell] + R[r] - (p-1, \ldots, p-1)\)
%
%	--- switch \(cmp\)
%
%	--- --- case  \(cmp < 0\) 
%
%	--- --- --- \(l += 1\) 
%
%	--- --- case \(0 < cmp\) 
%
%	--- --- --- \(r -= 1\) 
%
%	--- --- case \(cmp == 0\) 
%
%	--- --- --- \(matchr \colonequals R[r]\) 
%
%    --- --- --- \(numLmatches \colonequals \) the number of
%	adjacent entrices in \(L\) that are equal to \(L[\ell]\)
%
%	--- --- --- while \(R[r] == matchr\) 
%
%	--- --- --- --- for \(\ell\ell\) in \(\ell\) to \(\ell\) + numLmatches
%
%	--- --- --- --- --- Extract \(\Delta[\ell\ell]\) 
%	and its corresponding coeffient,
%	as well as \(M[r]\)
%
%	--- --- --- --- --- Apply \(u\) to the product
%	of the resulting monomials
%
%	--- --- --- --- --- add this term to \(answer\)
%
%	--- --- --- ---  end for
%
%	--- --- --- --- \(r += 1\) 
%
%	--- --- --- end while
%
%	--- --- --- \(l += numLmatches\) 
%	
%	--- end switch
%
%	end while
%
%\end{lstlisting}
\end{alg}

Note that the inner while loops account for the fact that
after modding by \(p\), one does not expect 
either array to have unique keys.
The algorithm is justified by the previous corollaries.

In practice, instead of sorting the arrays in place, 
we use a method like julia's ``sortperm''
%TODO: code font
to get the sort permutation.

We also may use the kronecker substitution to make
the comparisons and additions use machine integers
rather than vectors.
In practice, this speeds the algorithm up a lot.

* complexity analysis
n = length L, m = length R
we need n + m + n log n + m log m operations.
Thus, the algorithm is big o of max(n log n, m log m),
and in practice the \(\Delta_{1}\) length
usually dominates.

* picture


This next algorithm iterates through the terms of $delta1$, and directly generates the terms of $\Delta_1(f)a$ which are congruent to $(p - 1, \dots, p - 1)$

As part of this computation, we use an algorithm called $find\_next\_pminus1$:

\begin{alg}
    $find\_next\_pminus1$ is a map from $(d, p) \rightarrow (d', m', c)$, where $d, d', m' \in \mathbb{Z}^n$, and $p, c \in \mathbb{Z}$.
\end{alg}

In our case, $d$ is the degree sequence of a term in $\Delta_{1}(f ^ {p - 1})$.

The idea behind this algorithm is that we want to add to the coordinates of $d$ until we get some vector $d'$ which is congruent to $(p - 1, \dots, p - 1) \mod p$, and record how much we added to each entry in $m'$. $m'$ won't be a monomial in $M$, so we add $p$ to each coordinate until it is. $c$ is simply the sum of the coordinates of $m'$, which dictates how many $p$'s we add to $m'$ to get a monomial in $M$. ($M$ is the basis of the vector space of polynomials with degree $n(p - 1)$)

Given $d$ and $p$, we want to add to the coordinates of $d$ until we get some vector $d' \equiv (p - 1, \dots, p - 1) \mod p$. Because $d$ is a term of $\Delta_{1}(f ^ {p - 1})$, the sum of the coordinates of $d$ is $n \cdot (p - 1) \cdot p \equiv 0 \mod p$. Since $d' \equiv (p - 1, \dots, p - 1) \mod p$, the sum of the coordinates of $d'$ is congruent to $n \cdot (p - 1) \equiv -n \mod p$. This means that we will always add $-n \mod p$ to the coordinates of $d$ to get $d'$, and since $m \in M$ has homogeneous degree $n \cdot (p - 1) \equiv -n \mod p$, we have some multiple of $p$ to add to the coordinates of $d'$ to get a term of $\Delta_{1}(f ^ {p - 1})$. Let $m' = d' - d$: this is the foundation of the "relevant" monomial (sum of coordinates of $m'$ is congruent to $-n \mod p$). To actually get an element $m \in M$, we need to add a multiple of $p$ to each coordinate (probably needs a lemma). Since we need to add to $sum(d') \equiv -n \mod p$ from $sum(m') \equiv -n \mod p$, we arrive at the problem of adding $\frac{n * (p - 1) - c}{p}$ $p$'s to $m'$, which can be solved using weak integer compositions.

\begin{alg}
\begin{lstlisting}

delta1 = terms of delta1
mons = all homogeneous monomials
nMons = length(mons)

answer := zeros(nMons,nMons)

for term in delta1
    d', m', c = find_next_pminus1(term, p)
    for comp in wics(divexact(n * (p - 1) - c, n)) .* p
        relevantMon = m' + comp
        
    end
end
\end{lstlisting}
\end{alg}







