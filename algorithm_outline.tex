
\subsection{The Witt Vectors}

We begin by defining the Witt vectors. 
Since the theory of Witt vectors is a vast and active topic of research,
we recall the bare minimum 
required for the quasi-F-split Fedder's criterion algorithm.
For a more complete introduction to the Witt vectors with proofs, 
see \cite{rabinoff-2014-witt-vec}.
For an intuitive introduction or derivation of the Witt vectors, see
\cite{kim-2017-witt-vec}.
There are many other perspectives on Witt vectors. 
For example:
\cite[Chapter~17]{hazewinkel-1978-formal-groups} covers the Witt vectors
and its relationship with formal groups; 
\cite{kedlaya-2021-prismatic} gives a categorical perspective on Witt vectors
that relates to lifts of the Frobenius; and
\cite[Chapter~1]{schneider-2017-galois-rep-phi-gamma} defines a generalization
known as the \textit{ramified Witt vectors} in detail.

\begin{defn}
	The \textit{\(n\)-th Witt Polynomial} \(\omega_{n}\) is defined as
	\[
		\omega_{n}(X_{0}, \ldots, X_{n}) = X_{0}^{p^{n}} + pX_{1}^{p^{n-1}} + \ldots + p^{n}X_{n}
	\] 
\end{defn}

\noindent Now let \(R\) be a ring of characteristic \(p\).
We define the map \(\Phi\) to be the map 
\[
	\prod_{n \in \mathbb{N}}^{} R 
	\xrightarrow{(\omega_{n})_{n}} 
	\prod_{n \in \mathbb{N}}^{} R  
\] 
defined as \(\omega_{n}\) for the \(n\)-th component.

\begin{lem}
	There exist integer polynomials 
	\(S_n(X_{0}, \ldots, X_{n}, Y_{0}, \ldots, Y_{n})\) 
	with the property that 
	\[
		\Phi((S_{n})_{n \in \mathbb{N}}) =
		\Phi((X_{n})_{n \in \mathbb{N}}) 
		+ \Phi((Y_{n})_{n \in \mathbb{N}})
	.\] 
	Likewise, there exist integer polynomials 
	\(P_{n}(X_{0}, \ldots, X_{n}, Y_{0}, \ldots, Y_{n})\)
	such that
	\[
		\Phi((P_{n})_{n \in \mathbb{N}}) =
		\Phi((X_{n})_{n \in \mathbb{N}}) 
		\cdot \Phi((Y_{n})_{n \in \mathbb{N}})
	.\] 
\end{lem}

\begin{proof}
	For example, see \cite[Theorem~2.6]{rabinoff-2014-witt-vec} and the 
	surrounding discussion.
\end{proof}

We now define the ring of Witt vectors 
\(W(R)\) to be 
\(\prod_{n \in \mathbb{N}}^{} R \) 
as a set, with the ring structure defined
by 
\[
	(a_{n})_{n \in \mathbb{N}} + 
	(b_{n})_{n \in \mathbb{N}} =
	(S_{n}(a_{0}, \ldots, a_{n}, b_{0}, \ldots, b_{n}))_{n \in \mathbb{N}}
\] 
and likewise, multiplication is defined
using the \(P_{n}\).
The lemma then shows that \(\Phi\) is a homomorphism 
\[
	W(R) \xrightarrow{} \prod_{n \in \mathbb{N}}^{} R 
.\] 
Moreover, the fact that the polynomials do not depend on the base
ring \(R\) means that the construction is functorial; that is,
for a map of rings \(R \xrightarrow{} R^{\prime} \), we get a 
map \(W(R) \xrightarrow{} W(R^{\prime})\).

The main example, which also provides the fundamental motivation
for Witt vectors, is the case when \(R = \mathbb{F}_{p}\).
It is well known that \(W(\mathbb{F}_{p}) = \mathbb{Z}_{p}\), 
giving an alternative construction of the \(p\)-adic numbers.

\begin{warn}
    %However, we caution the reader that 
	If one takes a
    naive \(p\)-adic expansion 
    \(\sum_{n = 0}^{\infty} c_{n}p^{n} \in \mathbb{Z}_{p}\)
    with \(c_{n} \in \{0, \ldots, p-1\}\), this does not correspond
    to the Witt vector \((c_{0}, c_{1}, c_{2}, \ldots)\).
    In fact, the aforementioned sum corresponds to 
    \((c_{0}, c_{1}^{p}, c_{2}^{p^{2}}, \ldots)\). See
	\cite[Section~2]{kim-2017-witt-vec}. 
    This motivates the following: 
\end{warn}


\begin{defn}
	There exists a homomorphism \(F \colon W(R) \xrightarrow{} W(R)\),
	called the \textit{Frobenius},
	defined by
	\[
	 (c_{0}, c_{1}, \ldots) \mapsto (c_{0}^{p}, c_{1}^{p}, \ldots)
	\] 
    (this is induced by the Frobenius on \(R\) by functoriality).
\end{defn}

\begin{defn}
	There exists a homomorphism \(V \colon W(R) \xrightarrow{} W(R)\),
	called the \textit{Verschiebung},
	defined by
	\[
		(c_{0}, c_{1}, c_{2}, \ldots) \mapsto  (0, c_{0}, c_{1}, \ldots)
	.\] 
\end{defn}

\begin{lem}
	The composition \(F \circ V = V \circ F\) is the multiplication by
	\(p\) map on \(W(R)\).
\end{lem}

\begin{proof}
	\cite[Proposition~5]{kim-2017-witt-vec}
\end{proof}

Thus, we see that \(W(R) / pW(R) \isom R\).
This is sometimes called the first \textit{truncated}
Witt vectors.
We also have higher truncated variants.

\begin{defn}
	The \(n\)-truncated Witt vectors
	\(W_{n}(R)\) are defined as
	\(W(R) / p^{n}W(R)\).
\end{defn}

By the above lemma, this translates to an actual truncation
in the coordinates of the Witt vectors.

\begin{rmk}
	\label{rmk:polyraise:w2}
    Our computations will end up primarily involving
    \(W_{2}(R)\)\footnote{
    This comes from the delta formula,
    \cite[Theorem~D]{kty-2022-fedder}},
    where addition is governed by the polynomials
	\(S_{0}(X_{0}, Y_{0}) = X_{0} + Y_{0}\)
	and
	\[
		S_{1}(X_{0}, X_{1}, Y_{0}, Y_{1})
		= X_{1} + Y_{1} + 
		\frac{(X_{0} + Y_{0})^{p} - X_{0}^{p} - Y_{0}^{p}}{p}
	.\] 
	Thus we see that addition in \(W_{2}(R)\) involves raising 
	things in \(R\) (i.e. the first component) to the \(p\)-th
	power in a lift of \(R\) to characteristic 0.
	%This is the first place that raising polynomials
	%to the \(p\)-th power comes into the picture 
	%algorithmically.
\end{rmk}

\subsection{Splittings of Frobenius}

Let \(R\) be a ring of characteristic \(p\). 
We have the Frobenius morphism 
\(F \colon R \xrightarrow{} R\), 
defined as \(F(x) = x^p\).
We describe a few alternative perspectives on
the Frobenius which will be useful later.

\begin{rmk}
	\label{rmk:frob:perspectives}
    \hfill
    \begin{enumerate}[(1)]
    	\item Let \(R\) be reduced. 
    		Then we may view the Frobenius as the inclusion
    		\(R \ins R^{1 / p}\), where \(R^{1 / p}\) 
    		is the ring of formal \(p\)-th roots of elements
    		of \(R\).
    	\item Similarly, again assuming that \(R\) is reduced
    		we may view the Frobenius as the inclusion
    		\(R^{p} \ins R\), 
    	\item More generally, we define \(F_{\star}R\) to
			be the \(R\)-algebra with ring structure 
			the same as \(R\), with module structure
			\(r \cdot x = F(r)x = r^{p}x\).
			Then we view the Frobenius as a map
			\(R \xrightarrow{} F_{\star}R\).
			In this description, \(F\) is a module 
			homomorphism as well. 
			The module \(F_{\star}R\) corresponds to the
			pushforward construction from geometry
			(i.e. pushforward of quasi-coherent
			sheaves on \(\Spec R\)).
			Even more generally, for any \(R\)-module
			\(M\) we denote \(F_{\star}M\) to be
			the analogously defined pushforward by
			Frobenius.
    \end{enumerate}
\end{rmk}

\begin{defn}
	We say that \(R\) is \textit{\(F\)-split} if the map \(F\) is
	split as a map of 
	\(R\)-modules \(R \xrightarrow{} F_{\star}R\).
\end{defn}

We will be chiefly concerned with \textit{hypersurfaces},
so we specialize to this case now.
For what follows, we assume that \(k\) is a field
of characteristic \(p > 0\) which is 
\textit{\(F\)-finite}; that is, the Frobenius
map is module-finite.

\begin{defn}
	Let \(S = k[x_{1}, \ldots, x_{n}]\).
	Then we say that \(f \in S\) is \(F\)-split if 
	\(S / (f)\) is.
\end{defn}

A fundamental fact about \(F\)-splitness is that there
exists a very concrete criterion for whether or 
not a polynomial (hypersurface) \(f\) is \(F\)-split.
First, we introduce some notation.
If \(I = (x_{1}, \ldots, x_{n})\) is a finitely generated 
ideal of some ring \(R\), 
then \(I^{[m]}\)
is defined to be \((x_{1}^{m}, \ldots, x_{n}^{m})\)

\begin{thm}
    \label{thm:fedder:criterion}
	[Fedder's Criterion]
	Let \(f \in S = k[x_{1}, \ldots, x_{n}]\).
	Let \(\mathfrak{m} = (x_{1}, \ldots, x_{n})\) 
	be the ideal generated by the variables.
	Then \(f\) is \(F\)-split if and only if 
	\(f^{p-1} \notin \mathfrak{m}^{[p]}\)
\end{thm}

\begin{proof}
	See \cite[Theorem~2.5]{ma-polstra-2021-F-sing-comm-alg}
\end{proof}

%\begin{rmk}
%	Fedder's criterion is the second place where raising
%	homogeneous polynomials to powers enters the picture
%	algorithmically.
%	This time, unlike Remark \ref{rmk:polyraise:w2},
%	the raising to a power happens in characteristic \(p\).
%\end{rmk}

Of particular interest is the case when \(f\) is 
homogeneous of degree \(n\), which geometrically
corresponds to a \textit{Calabi-Yau} hypersurface.
In this case, we have

\begin{thm}
	\label{thm:fsplit:ordinary}
	If \(f \in S\) 
	homogeneous of degree \(n\) 
	is \(F\)-split,
	then the Artin-Mazur height 
	of \(Z(f) = \Proj (S / (f))\) 
	is 1, i.e. \(Z(f)\) is weakly ordinary.
\end{thm}

Recently, in \cite{yobuko-2019-qfs-calabi-yau}
Yobuko introduced the notion of 
quasi-\(F\)-splitness, which generalizes \(F\)-splitness.

\begin{defn}
	The ring \(R\) is \textit{\(n\)-quasi-\(F\)-split} if there exists
	a map \(\phi \colon W_{n}(R) \xrightarrow{} R\) such that
	\[
	\begin{tikzcd}
		W(R) \arrow{r}{F} \arrow{d}[swap]{} &
		F_{\star}W(R) \arrow{ld}{\phi} \\
	R 
	\end{tikzcd}
	,\]
	where the vertical map is the \(1\)-st Witt vector truncation.
    % FEEDBACK I think this looks a bit weirdly formatted, 
    % maybe last 2 lines should be un-italicized outside the defn?
\end{defn}

We further define the \textit{quasi-\(F\)-split height} of \(R\) as the smallest \(n\) 
for which \(R\) is \(n\)-quasi-\(F\)-split.
As above, the quasi-\(F\)-split height of 
\(f \in S = k[x_{1}, \ldots, x_{n}]\) is that
of \(R = S / (f)\).

\begin{rmk}
	Both \(F\)-splitness and quasi-\(F\)-splitness have 
	various geometric
	variants which are more general then the 
	ring-theoretic/affine versions given here. 
	These are covered extensively in the literature, for example
	see \cite{kttwyy-2022-qfs-birat}.
\end{rmk}

The quasi-\(F\)-split height also gives a generalization
of Theorem \ref{thm:fsplit:ordinary}:

\begin{thm}
	If \(f \in S\) is homogeneous of degree \(n\),
	then the Artin-Mazur height of \(Z(f)\)
	is equal to the quasi-\(F\)-split height
	of \(f\).
\end{thm}

\begin{proof}
	This is a special case of 
	\cite[Theorem~4.5]{yobuko-2019-qfs-calabi-yau}.
\end{proof}

\section{Fedder's criterion for quasi-F-splitness: an algorithmic perspective}

We now describe how the Witt Vectors can be used to calculate the 
quasi-F-split height / Artin-Mazur height of a Calabi-Yau 
hypersurface, using the version of Fedder's criterion in \cite{kty-2022-fedder}.
We will describe the algorithm in more detail, and proofs can be
found in \cite{kty-2022-fedder}.

\subsection{The computation of \(\Delta_{1}\)}

For the following discussion, 
let \(k\) be a perfect field of characteristic \(p\) and 
let \(S := k[x_{1}, \ldots, x_{n}]\).
% CHANGED all f's to g's in this delta1 section, since f is 
% the K3 input
Let \(f = \sum_{I}^{} a_{I}\mathbf{x}^{I}\) be a polynomial in \(S\).

\begin{defn}
	Let \(\Delta_{1}(f)\)
	be defined by the following equation in \(W_{2}(S)\) :
	\[
		(0, \Delta_{1}(f)) = (f,0) - \sum_{I}^{} (a_{I}\mathbf{x}^{I}, 0) 
	.\] 
\end{defn}

The following proposition demonstrates how we can calculate 
\(\Delta_{1}(g)\) algorithmically.

\begin{prop}
	\label{prop:delta1:formula}
	Let \(\tilde{f}\) be a lift of \(f\) to the integers,
	i.e.
	\(f = \sum_{I}^{} [a_{I}] \mathbf{x}^{I}\).
	If \(k = \mathbb{F}_{p}\),
	we can compute \(\Delta_{1}(f)\) by 
	taking the reduction of
	\[
		\frac{\tilde{f}^{p} - \sum_{I}^{} ([a_{I}]x^{I})^{p} }{p}
	\] 
	mod \(p\).
\end{prop}

\begin{proof}
	Iteratively apply the formula of the first
	Witt polynomial \(S_{1}\) 
	to the monomials of \(\tilde{f}\).
\end{proof}

\begin{rmk}
	If \(f\) is a homogeneous polynomial of degree \(d\), 
	then \(\Delta_{1}(f)\) is a polynomial of degree \(pd\).
\end{rmk}

Proposition \ref{prop:delta1:formula} gives an obvious algorithm
for calculating the term \(\Delta_{1}(f)\): 

\begin{algorithm}[H]
\caption{Calculation of \(\Delta_{1}(f)\) }
	\label{alg:calc:delta1}
    \begin{algorithmic}[1]
		\State \textbf{Input:} \(f \in \mathbb{F}_{p}[x_{1}, \ldots, x_{n}]\) 
		\State \textbf{Output:} $\Delta_1(f)$
		% CHANGED added output
		\State \(\tilde{f} \gets \text{lift}(f)\) 
		\State \(D \gets \tilde{f}^{p}\) 
		\For{\(t \in \text{terms}(\tilde{f})\) }
		    \State \(D \gets D - t^{p}\) 
		\EndFor
		\State \(D \gets D / p\)
		\State \Return \(D \% p\) 
	\end{algorithmic}
\end{algorithm}

\subsection{Splittings of Frobenius from a computational perspective}

Let \(S = k[x_{1}, \ldots, x_{n}]\) as before. 
We will use perspective (3) from
Remark \ref{rmk:frob:perspectives}; 
recall that we identify 
\(S\) with the target of Frobenius and
\(S^{p}\) with the source.
We see 
by counting degrees
that we have a generating set for \(S\) as an
\(S^{p}\)-module given by
all monomials
\(x_{1}^{i_{1}}\ldots x_{n}^{i_{n}}\)
where \(0 \leq i_{j} \leq p-1\) for all \(j\).
Moreover, since \(S\) is a polynomial ring, 
there are no (module-theoretic) relations
and
\(S\) is the free \(S^{p}\)-module generated by 
these monomials, i.e.  \[
S = \bigoplus_{1 \leq j \leq n,~ 0 \leq i_{j} \leq p-1}^{} x_{1}^{i_{1}}\ldots x_{n}^{i_{n}} S^{p}
.\] 
Then the projection of \(S\) to any of the direct sum components
is an element of \(\Hom(S,S^{p})\), which is a
splitting of Frobenius.
Let \(u\) be the projection onto the component of
\(x_{1}^{p-1}, \ldots, x_{n}^{p-1}\).

The splitting \(u\) plays an important role in \(F\)-singularity
theory, see for example 
\cite[Claim~2.6]{ma-polstra-2021-F-sing-comm-alg}.
For our purposes, we are only concerned with computing \(u\) 
for a polynomial in \(S\). 
Given \(f \in S\), we will first compute
\(u(f) \in S^{p}\), and then use the identification
\(S^{p} \isom S\) by taking \(p\)-th roots of 
exponents.

\begin{algorithm}[H]
\caption{Splitting of Frobenius}
\label{alg:naive:u}
\begin{algorithmic}[1]
\State \textbf{Input:} \(f \in S\) 
\State \textbf{Output:} \(u(f)\) considered as an element of \(S\).
\State Discard all terms of \(f\) whose exponents are not congruent to
	\((p-1, \ldots, p-1)\) mod p.
\State result \(\gets 0\)	
\For{\(t \in \text{terms}(f)\) }
    \State subtract \(p-1\) from all exponents of \(t\)
    \State Divide all exponents of \(t\) by \(p\).
    \Comment This division is exact because of the previous step
    \State result \(\gets \text{result} + t\)
\EndFor 
\State \Return result
\end{algorithmic}
\end{algorithm}


\subsection{The naive algorithm}

Let \(f\) be a homogeneous polynomial of degree \(n\) 
in \(S\), 
so that \(Z(f)\) is a Calabi-Yau hypersurface.
Following \cite{kty-2022-fedder}, we have the following
algorithm to calculate the quasi-F-split height.

\begin{algorithm}[H]
\caption{Quasi-\(F\)-Split Height: naive algorithm}
\label{alg:qfs:naive}
\begin{algorithmic}[1]
\State \textbf{Input}: \(b \in \mathbb{N}\) chosen bound, \(f\) a homogeneous
	polynomial of degree \(n\) in \(S\).
% CHANGED added output
\State \textbf{Output:} $h(f)$
\State \(g \gets f^{p-1}\) 
\If{\(g \not\in \mathfrak{m}^{p}\) }
    \State \Return \(1\) 
\EndIf
\State \(\Delta \gets \Delta_{1}(f^{p-1})\) \Comment{Use Algorithm \ref{alg:calc:delta1}}
% CHANGED renamed n to h, since n is the degree of the polynomial
\State \(h \gets 2\) 
\While{true}
    \If{\(b < h\)}
        \State \Return \(\infty\)
    \EndIf
    \State \(g \gets u(\Delta * g)\) \Comment{Use Algorithm \ref{alg:naive:u}}
    \If{\(g \notin \mathfrak{m}^{p}\)}
        \State \Return \(h\) 
    \EndIf
    \State \(h \gets h + 1\)
\EndWhile
\end{algorithmic}
\end{algorithm}

%\begin{alg}
%	\label{alg:qfs:outline}
%
%	\begin{enumerate}[(1)]
%		\item Compute \(f^{p-1}\)
%		\item If \(f^{p-1} \notin \mathfrak{m}^{p}\), return \(1\). 
%		\item Compute \(\Delta_{1}(f^{p-1})\) via Proposition \ref{prop:delta1:formula}.
%		\item Set \(n = 2\) and \(g = f^{p-1}\)
%		\item Loop
%			\begin{enumerate}[(1)]
%				\item \(g := \theta(g)\) (using the output of Step 3)
%				\item If \(g \notin \mathfrak{m}^{p},\) return \(n\).
%				\item If \(n < b\), return \(\infty\)	
%			\end{enumerate}
%	\end{enumerate}
%\end{alg}

\begin{thm}
	[\cite{kty-2022-fedder}, Theorem C]
	Assume that
	\(Z(f)\) has quasi-F-split height \(h < b\).
	Then Algorithm \ref{alg:qfs:naive} terminates
	and returns \(h\).
\end{thm}

\begin{proof}
	This is just rephrasing \cite[Theorem~C]{kty-2022-fedder}.
\end{proof}

In the case of Calabi-Yau hypersurfaces, we have bounds on the height by
\cite{van-der-geer-katsura-2003-calabi-yau},
so we can deterministically recover the height.  
See also \cite[Theorem~0.1]{artin-1974-k3-surfaces},
for the case of K3 surfaces.
For a K3 surface, the height (if finite) is bounded by 10.

\subsection{The key idea: finding the matrix of the linear operator ``multiply then split''}

An implementation of Algorithm \ref{alg:qfs:naive}
is provided in MMPSingularities.jl.
The bottleneck ends up being polynomial multiplication, 
in two places:
\begin{enumerate}[(1)]
    \item raising \(g = f^{p-1}\) to the \(p\)-th power in the integers
        (in line 4 of Algorithm \ref{alg:calc:delta1})
    \item multiplying \(g\) by \(\Delta_{1}(f^{p-1})\) 
        (in line 13 of Algorithm \ref{alg:qfs:naive})
\end{enumerate}

\noindent For a quartic K3 surface of characteristic \(5\),
for example, each step takes about 1 second 
using FLINT. 

%With that, we may define \(\theta\) as it appears
%in \cite{kty-2022-fedder}:
%
%\begin{defn}
%	[See the introduction of \cite{kty-2022-fedder}]
%	The map \(\theta = \theta_{f}\) is defined by 
%	\(\theta_{f}(g) = u(\Delta_{1}(f^{p-1}) \cdot g)\).
%	We generally omit the dependence on \(f\) from
%	the notation.
%\end{defn}

We now explain how to overcome the second
bottleneck. Since \(Z(f)\) is Calabi-Yau
(i.e. \(\deg f = n\)), we have that \(f^{p-1}\) has degree
\(n(p-1)\). 
Furthermore, by Proposition \ref{prop:delta1:formula}
the degree of \(\Delta_{1}(f^{p-1})\) 
is \(np(p - 1)\).
Thus, \(\Delta_{1}(f^{p-1})g\) has degree
\(n(p^{2} - 1)\); however, the effect 
of \(u\) on any polynomial is subtracting \(p-1\)
from the exponents of the terms and dividing by \(p\) 
% CHANGED subtracting p-1 from and dividing by p ->
% subtracting p-1 from the exponents of the terms and dividing by p
(see Algorithm \ref{alg:naive:u}).
Thus, the ``multiply then split'' map 
\(g \mapsto u(\Delta_{1}(f^{p-1}) g)\) 
is a linear map from 
the space of homogeneous polynomials of degree \(n(p-1)\) 
to itself.
As a consequence of this observation,
if we can efficiently compute the matrix of 
\(g \mapsto u(\Delta_{1}(f^{p-1})g)\),
we can repeatedly apply matrix-vector multiplication.

Furthermore, when \(g\) is written as a vector 
in the basis of homogeneous monomials of degree
\(n(p-1)\), we can test if \(g \notin \mathfrak{m}^{[p]}\) 
in an especially simple way: the only 
monomial that is not in \(\mathfrak{m}^{[p]}\) is
\(x_{1}^{p-1}\cdots x_{n}^{p-1}\), 
see for example \cite{kty-2022-fedder}.
Thus, we can check if a single element of the vector representing
\(g\) is nonzero.

The algorithm for Fedder's criterion then becomes:

\begin{algorithm}[H]
\caption{Quasi-\(F\)-Split Height: matrix-based algorithm}
\label{alg:qfs:matrix}
\begin{algorithmic}[1]
\State \textbf{Input}: \(b \in \mathbb{N}\) chosen bound, \(f\) a homogeneous
	polynomial of degree \(n\) in \(S\).
% CHANGED same edits as previous algorithm
\State \textbf{Output:} $h(f)$
\State \(g \gets f^{p-1}\) 
\If{\(g \not\in \mathfrak{m}^{p}\) }
    \State \Return \(1\) 
\EndIf
\State \(\Delta \gets \Delta_{1}(f^{p-1})\) \Comment{Use Algorithm \ref{alg:calc:delta1}}
\State \(M \gets\) the matrix of  \(g^{\prime} \mapsto u(\Delta * g^{\prime})\)
\State \(h \gets 2\) 
\State \(g_{v} \gets\) the representation of \(g\) as a vector
\State \(i \gets \) the index of the monomial \(x_{1}^{p-1}\cdots x_{n}^{p-1}\)
\While{true}
    \If{\(b < h\)}
        \State \Return \(\infty\)
    \EndIf
    \State \(g_{v} \gets M * g_{v}\) 
    \If{\(g[i] \neq 0\)}
        \State \Return \(h\) 
    \EndIf
    \State \(h \gets h + 1\)
\EndWhile
\end{algorithmic}
\end{algorithm}

Thus, we have reduced our problem (algorithmically, at least)
to finding the matrix of a ``mulitply then split'' operation.
%In the following section, we give three such algorithms.
%One is a naive algorithm, which is only 
%reasonably fast if used with GPU hardware. 
%The second algorithm is suitable for use on CPUs,
%though isn't easily massively parallel.
%Finally, the third algorithm 
%outperforms the first two on the CPU, and can be fully 
%parallelized on the GPU. However, the GPU implementation 
%requires some data to be cached, making it less viable for 
%one-off computations, but ideal for repeated computations.
%
% FEEDBACK deleting this paragraph, already mention the bottleneck
% in the start of 3.4
% 
% In practice, Algorithm \ref{alg:qfs:matrix} is bottlenecked
% by the polynomial multiplication in the calculation of 
% \(\Delta_{1}(f^{p-1})\), as noted above. 
% In order to get enough performance for our computations,
% we implement GPU-accelerated versions of
% matrix multiplication mod p and polynomial multiplication
% over \(\mathbb{Z}\).

