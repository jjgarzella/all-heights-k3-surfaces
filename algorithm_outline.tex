
\subsection{Witt Vectors}

We begin by defining the ring of Witt vectors. 
Since the theory of Witt vectors is a vast and active topic of research,
we recall the bare minimum 
required for the quasi-\(F\)-split Fedder's criterion algorithm.
For a more complete introduction to the ring of Witt vectors with proofs, 
see \cite{rabinoff-2014-witt-vec}.
For an intuitive introduction or derivation of the ring of Witt vectors, see
\cite{kim-2017-witt-vec}.
There are many other perspectives on Witt vectors. 
For example:
\cite[Chapter~17]{hazewinkel-1978-formal-groups} covers the ring of Witt vectors
and its relationship with formal groups; 
\cite{kedlaya-2021-prismatic} gives a categorical perspective on the ring of Witt vectors
that relates to lifts of the Frobenius; and
\cite[Chapter~1]{schneider-2017-galois-rep-phi-gamma} defines a generalization
known as the ring of \textit{ramified Witt vectors} in detail.

\begin{defn}
	The \textit{\(n\)-th Witt Polynomial} \(\omega_{n}\) is defined as
	\[
		\omega_{n}(X_{0}, \ldots, X_{n}) = X_{0}^{p^{n}} + pX_{1}^{p^{n-1}} + \ldots + p^{n}X_{n}
        \in \mathbb{Z}[X_{0}, \ldots, X_{n}]
	\] 
    
\end{defn}

\noindent Now let \(R\) be a ring of characteristic \(p\).
We define the map \(\Phi\) to be the map 
% \[
% 	\prod_{n \in \mathbb{N}}^{} R 
% 	\xrightarrow{(\omega_{n})_{n}} 
% 	\prod_{n \in \mathbb{N}}^{} R  
% \] 
\begin{align*}
    \Phi : \prod_{n \in \mathbb{N}}^{R} R  
    &\xlongrightarrow{(\omega_{n})_{n}} \prod_{n \in \mathbb{N}}^{R} R \\
    (r_{0}, r_{1}, \ldots, r_{n}, \ldots) &\longmapsto 
    (\omega_{0}(r_{0}), \omega_{1}(r_{0}, r_{1}), 
    \ldots, \omega_{n}(r_{0}, \ldots, r_{n}), \ldots)
.\end{align*}

defined as \(\omega_{n}\) for the \(n\)-th component.
That is, \(\omega_{n}\) is considered as a 
map (of sets) \(R^{n} \xrightarrow{} R\) by
evaluation.

\begin{lem}
	There exist integer polynomials 
	\(S_n(X_{0}, \ldots, X_{n}, Y_{0}, \ldots, Y_{n})\) 
	with the property that 
	\[
		\Phi((S_{n})_{n \in \mathbb{N}}) =
		\Phi((X_{n})_{n \in \mathbb{N}}) 
		+ \Phi((Y_{n})_{n \in \mathbb{N}})
	.\] 
	Likewise, there exist integer polynomials 
	\(P_{n}(X_{0}, \ldots, X_{n}, Y_{0}, \ldots, Y_{n})\)
	such that
	\[
		\Phi((P_{n})_{n \in \mathbb{N}}) =
		\Phi((X_{n})_{n \in \mathbb{N}}) 
		\cdot \Phi((Y_{n})_{n \in \mathbb{N}})
	.\] 
\end{lem}

\begin{proof}
	For example, see \cite[Theorem~2.6]{rabinoff-2014-witt-vec} and the 
	surrounding discussion.
\end{proof}

We now define the ring of Witt vectors 
\(W(R)\) to be 
\(\prod_{n \in \mathbb{N}}^{} R \) 
as a set, with the ring structure defined
by 
\[
	(a_{n})_{n \in \mathbb{N}} + 
	(b_{n})_{n \in \mathbb{N}} =
	(S_{n}(a_{0}, \ldots, a_{n}, b_{0}, \ldots, b_{n}))_{n \in \mathbb{N}}
\] 
and likewise, multiplication is defined
using the \(P_{n}\).
The lemma then shows that \(\Phi\) is a homomorphism 
\[
	W(R) \xrightarrow{} \prod_{n \in \mathbb{N}}^{} R 
.\] 
Moreover, the fact that the polynomials do not depend on the base
ring \(R\) means that the construction is functorial; that is,
for a map of rings \(R \xrightarrow{} R^{\prime} \), we get a 
map \(W(R) \xrightarrow{} W(R^{\prime})\).

The main example, which also provides the fundamental motivation
for Witt vectors, is the case when \(R = \mathbb{F}_{p}\).
It is well known that \(W(\mathbb{F}_{p}) = \mathbb{Z}_{p}\), 
giving an alternative construction of the \(p\)-adic numbers.

\begin{warn}
	If one takes a
    naive \(p\)-adic expansion 
    \(\sum_{n = 0}^{\infty} c_{n}p^{n} \in \mathbb{Z}_{p}\)
    with \(c_{n} \in \{0, \ldots, p-1\}\), this does not correspond
    to the Witt vector \((c_{0}, c_{1}, c_{2}, \ldots)\).
    In fact, the aforementioned sum corresponds to 
    \((c_{0}, c_{1}^{p}, c_{2}^{p^{2}}, \ldots)\). See
	\cite[Section~2]{kim-2017-witt-vec}. 
    This motivates the following: 
\end{warn}

\begin{defn}
	There exists a homomorphism \(F \colon W(R) \xrightarrow{} W(R)\),
	called the \textit{Frobenius},
	defined by
	\[
	 (c_{0}, c_{1}, \ldots) \mapsto (c_{0}^{p}, c_{1}^{p}, \ldots)
	\] 
    (this is induced by the Frobenius on \(R\) by functoriality).
\end{defn}

\begin{defn}
	There exists a homomorphism \(V \colon W(R) \xrightarrow{} W(R)\),
	called the \textit{Verschiebung},
	defined by
	\[
		(c_{0}, c_{1}, c_{2}, \ldots) \mapsto  (0, c_{0}, c_{1}, \ldots)
	.\] 
\end{defn}

We see that \(W(R) / VW(R) \isom R\).
This is sometimes called the first \textit{truncated}
Witt vectors.
We also have higher truncated variants.

\begin{defn}
	The \(n\)-th truncated Witt vectors
	\(W_{n}(R)\) are defined as
	\(W(R) / V^{n}W(R)\).
\end{defn}

We may regard the \(n\)-th truncated Witt Vectors as consisting
of elements \((c_{0}, \ldots, c_{n-1})\) with addition
and multiplication by the \(S_{i}\) and \(P_{i}\).
Thus, one has \(\lim_{n} W_{n}(R) = W(R)\).

\begin{lem}
    \label{lem:frob:versch}
	The composition \(F \circ V = V \circ F\) is the multiplication by
	\(p\) map on \(W(R)\).
\end{lem}

\begin{proof}
	\cite[Proposition~5]{kim-2017-witt-vec}
\end{proof}

\begin{lem}
    \label{lem:perfect:witt}
    Let \(R\) be a \textit{perfect} ring,
    that is, a ring for which \(F\) is an isomorphism.
    Then \(W_{n}(R) = W(R) / p^{n}W(R)\).
\end{lem}

\begin{proof}
    Since \(F\) is an isomorphism, this follows from 
    Lemma \ref{lem:frob:versch}
\end{proof}

\begin{rmk}
    If we take \(R = \mathbb{F}_{p}\), then
    Lemma \ref{lem:perfect:witt}
    shows that \(W_{n}(\mathbb{F}_{p}) = \mathbb{Z} / p^{n}\mathbb{Z}\).
    One common intuition for \(W_{n}(R)\)
    for more general \(R\) is an analogy:
    \(\mathbb{Z} / p^{n}\mathbb{Z}\) 
    is to \(\mathbb{F}_{p}\) 
    as \(W_{n}(R)\) is to \(R\).
    For rings that are not perfect,
    this intuition is less precise but still
    somewhat useful.
\end{rmk}

\begin{rmk}
	\label{rmk:polyraise:w2}
    Our computations will end up primarily involving
    \(W_{2}(R)\)\footnote{
    This comes from the delta formula,
    \cite[Theorem~D]{kty-2022-fedder}},
    where addition is governed by the polynomials
	\(S_{0}(X_{0}, Y_{0}) = X_{0} + Y_{0}\)
	and
	\[
		S_{1}(X_{0}, X_{1}, Y_{0}, Y_{1})
		= X_{1} + Y_{1} + 
		\frac{(X_{0} + Y_{0})^{p} - X_{0}^{p} - Y_{0}^{p}}{p}
	.\] 
	Thus we see that addition in \(W_{2}(R)\) involves raising 
	elements in \(R\) (i.e. the first component) to the \(p\)-th
	power in a lift of \(R\) to characteristic 0.
    Thus, the bottleneck for most computations with Witt vectors,
    including the present work, tends to be raising
    integer polynonmials to powers.
\end{rmk}

\subsection{Splittings of Frobenius}

Let \(R\) be a ring of characteristic \(p\). 
We have the Frobenius morphism 
\(F \colon R \xrightarrow{} R\), 
defined as \(F(x) = x^p\).
We describe a few alternative perspectives on
the Frobenius which will be useful later.

\begin{rmk}
	\label{rmk:frob:perspectives}
    \hfill
    \begin{enumerate}[(1)]
    	\item Let \(R\) be reduced. 
    		Then we may view the Frobenius as the inclusion
    		\(R \ins R^{1 / p}\), where \(R^{1 / p}\) 
    		is the ring of formal \(p\)-th roots of elements
    		of \(R\).
    	\item Similarly, again assuming that \(R\) is reduced
    		we may view the Frobenius as the inclusion
    		\(R^{p} \ins R\), 
    	\item More generally, we define \(F_{\star}R\) to
			be the \(R\)-algebra with ring structure 
			the same as \(R\), with module structure
			\(r \cdot x = F(r)x = r^{p}x\).
			Then we view the Frobenius as a map
			\(R \xrightarrow{} F_{\star}R\).
			In this description, \(F\) is a module 
			homomorphism as well. 
			The module \(F_{\star}R\) corresponds to the
			pushforward construction from geometry
			(i.e. pushforward of quasi-coherent
			sheaves on \(\Spec R\)).
			Even more generally, for any \(R\)-module
			\(M\) we denote \(F_{\star}M\) to be
			the analogously defined pushforward by
			Frobenius.
    \end{enumerate}
\end{rmk}

\begin{defn}
	We say that \(R\) is \textit{\(F\)-split} if the map \(F\) is
	split as a map of 
	\(R\)-modules \(R \xrightarrow{} F_{\star}R\).
\end{defn}

We will be chiefly concerned with \textit{hypersurfaces},
so we specialize to this case now.
For what follows, we assume that \(k\) is a field
of characteristic \(p > 0\) which is 
\textit{\(F\)-finite}; that is, the Frobenius
map is module-finite.

\begin{defn}
	Let \(S = k[x_{1}, \ldots, x_{n}]\).
	Then we say that \(f \in S\) is \(F\)-split if 
	\(S / (f)\) is.
\end{defn}

A fundamental fact about \(F\)-splitness is that there
exists a very concrete criterion for whether or 
not a polynomial (hypersurface) \(f\) is \(F\)-split.
First, we introduce some notation.
If \(I = (x_{1}, \ldots, x_{n})\) is a finitely generated 
ideal of some ring \(R\), 
then \(I^{[m]}\)
is defined to be \((x_{1}^{m}, \ldots, x_{n}^{m})\).

\begin{thm}
	[Fedder's Criterion]
    \label{thm:fedder:criterion}
	Let \(f \in S = k[x_{1}, \ldots, x_{n}]\).
	Let \(\mathfrak{m} = (x_{1}, \ldots, x_{n})\) 
	be the ideal generated by the variables.
	Then \(f\) is \(F\)-split if and only if 
	\(f^{p-1} \notin \mathfrak{m}^{[p]}\).
\end{thm}

\begin{proof}
	See \cite[Theorem~2.5]{ma-polstra-2021-F-sing-comm-alg}.
\end{proof}

Of particular interest is the case when \(f\) is 
homogeneous of degree \(n\), which geometrically
corresponds to a \textit{Calabi-Yau} hypersurface.
In this case, we have

\begin{thm}
	\label{thm:fsplit:ordinary}
	If \(f \in S\) 
	homogeneous of degree \(n\) 
	is \(F\)-split,
	then the Artin--Mazur height 
	of \(Z(f) = \Proj (S / (f))\) 
	is 1. That is, \(Z(f)\) is weakly ordinary.
\end{thm}

Recently, in \cite{yobuko-2019-qfs-calabi-yau}
Yobuko introduced the notion of 
quasi-\(F\)-splitness, which generalizes \(F\)-splitness.

\begin{defn}
	The ring \(R\) is \textit{\(n\)-quasi-\(F\)-split} if there exists
	a map \(\phi \colon W_{n}(R) \xrightarrow{} R\) such that
	\[
	\begin{tikzcd}
		W_{n}(R) \arrow{r}{F} \arrow{d}[swap]{} &
		F_{\star}W_{n}(R) \arrow{ld}{\phi} \\
	R 
	\end{tikzcd}
	,\]
	where the vertical map is the first Witt vector truncation.
\end{defn}

We further define the \textit{quasi-\(F\)-split height} of \(R\) as the smallest \(n\) 
for which \(R\) is \(n\)-quasi-\(F\)-split.
As above, the quasi-\(F\)-split height of 
\(f \in S = k[x_{1}, \ldots, x_{n}]\) is that
of \(R = S / (f)\).

\begin{rmk}
	Both \(F\)-splitness and quasi-\(F\)-splitness have 
	various geometric
	variants which are more general then the 
	ring-theoretic/affine versions given here. 
	These are covered extensively in the literature, for example
	see \cite{kttwyy-2022-qfs-birat}.
\end{rmk}

The quasi-\(F\)-split height also gives a generalization
of Theorem \ref{thm:fsplit:ordinary}:

\begin{thm}
	If \(f \in S\) is homogeneous of degree \(n\),
	then the Artin--Mazur height of \(Z(f)\)
	is equal to the quasi-\(F\)-split height
	of \(f\).
\end{thm}

\begin{proof}
	This is a special case of 
	\cite[Theorem~4.5]{yobuko-2019-qfs-calabi-yau}.
\end{proof}

\section{Fedder's Criterion for Quasi-\(F\)-Splitness: an Algorithmic Perspective}

We now describe how the ring of Witt vectors can be used to calculate the 
quasi-\(F\)-split height (equivalently, Artin--Mazur height) of a Calabi-Yau 
hypersurface, using the version of Fedder's criterion in \cite{kty-2022-fedder}.
We will describe the algorithm in more detail. Proofs can be
found in \cite{kty-2022-fedder}.

\subsection{The computation of \(\Delta_{1}\)}

For the following discussion, 
let \(k\) be a perfect field of characteristic \(p\) and 
let \(S := k[x_{1}, \ldots, x_{n}]\).
Let \(f = \sum_{I}^{} a_{I}\mathbf{x}^{I}\) be a polynomial in \(S\).

\begin{defn}
	Let \(\Delta_{1}(f)\)
	be defined by the following equation in \(W_{2}(S)\):
	\[
		(0, \Delta_{1}(f)) = (f,0) - \sum_{I}^{} (a_{I}\mathbf{x}^{I}, 0) 
	.\] 
\end{defn}

The following proposition demonstrates how we can calculate 
\(\Delta_{1}(g)\) algorithmically.

\begin{prop}
	\label{prop:delta1:formula}
	Let \(\tilde{f}\) be a lift of \(f\) to \(W(k)\),
	i.e.
	\(f = \sum_{I}^{} [a_{I}] \mathbf{x}^{I}\).
	If \(k = \mathbb{F}_{p}\),
	we can compute \(\Delta_{1}(f)\) by 
	taking the reduction of
	\[
		\frac{\tilde{f}^{p} - \sum_{I}^{} ([a_{I}]x^{I})^{p} }{p}
	\] 
	mod \(p\).
\end{prop}

\begin{proof}
	Iteratively apply the formula of the first
	Witt polynomial \(S_{1}\) 
	to the monomials of \(\tilde{f}\).
\end{proof}

\begin{rmk}
	If \(f\) is a homogeneous polynomial of degree \(d\), 
	then \(\Delta_{1}(f)\) is a polynomial of degree \(pd\).
\end{rmk}

\begin{rmk}
    \label{rmk:lift:roi}
    Note that if \(k = \mathbb{F}_{p}\), we can always choose a lift
    of \(f\) with coefficients in \(\mathbb{Z}\), 
    not just \(W(k) = \mathbb{Z}_{p}\).
    In practice, we must choose a lift to the integers
    so we can represent it computationally.

    A similar fact holds for \(k = \mathbb{F}_{q}\) with 
    \(q \neq p\), replacing \(\mathbb{Z}\) with
    \(\mathbb{Z}[\zeta_{q-1}]\).
    This could be used to calculate the quasi-\(F\)-split 
    heights for surfaces not defined over \(\mathbb{F}_{p}\),
    though we have not attempted this.
    More generally, if \(q = p^{e}\), one may take
    any abelian extension \(K\) of degree \(e\) over \(\mathbb{Q}\) such that
    \(p\) is an inert prime in \(K\).
    Then, there is a unique prime \(\mathfrak{p}\) lying over \(p\) 
    such that \(\mathcal{O}_{K} / \mathfrak{p} \isom k\).
    Furthermore, \(\mathcal{O}_{K} \ins W(k)\)
    and so we may lift \(f\) to \(\mathcal{O}_{K}\) 
    and do arithmetic there. 
    Doing arithmetic in a degree \(e\) extension will have
    better complexity then in the cyclotomic extension, which
    has degree \(\phi(q) = \phi(p^{e}) = p^{e-1}(p-1)\), where
    \(\phi\) is the Euler totient function.
    We do not implement the calculation of quasi-\(F\)-split
    heights for \(q \neq p\).
\end{rmk}

Proposition \ref{prop:delta1:formula} gives a natural algorithm
for calculating the term \(\Delta_{1}(f)\): 

\begin{algorithm}[H]
\caption{Calculation of \(\Delta_{1}(f)\) }
	\label{alg:calc:delta1}
    \begin{algorithmic}[1]
		\State \textbf{Input:} \(f \in \mathbb{F}_{p}[x_{1}, \ldots, x_{n}]\) 
		\State \textbf{Output:} $\Delta_1(f)$
		\State \(\tilde{f} \gets \text{lift}(f)\) 
		\State \(D \gets \tilde{f}^{p}\) 
		\For{\(t \in \text{terms}(\tilde{f})\) }
		    \State \(D \gets D - t^{p}\) 
		\EndFor
		\State \(D \gets D / p\)
		\State \Return \(D \% p\) 
	\end{algorithmic}
\end{algorithm}

\subsection{Splittings of Frobenius from a Computational Perspective}

Let \(S = k[x_{1}, \ldots, x_{n}]\) as before. 
We will use perspective (3) from
Remark \ref{rmk:frob:perspectives}; 
recall that we identify 
\(S\) with the target of Frobenius and
\(S^{p}\) with the source.
We see 
by counting degrees
that we have a generating set for \(S\) as an
\(S^{p}\)-module given by
all monomials
\(x_{1}^{i_{1}}\cdots x_{n}^{i_{n}}\)
where \(0 \leq i_{j} \leq p-1\) for all \(j\).
Moreover, since \(S\) is a polynomial ring, 
there are no (module-theoretic) relations
and
\(S\) is the free \(S^{p}\)-module generated by 
these monomials, i.e.  \[
S = \bigoplus_{1 \leq j \leq n,~ 0 \leq i_{j} \leq p-1}^{} x_{1}^{i_{1}}\cdots x_{n}^{i_{n}} S^{p}
.\] 
Then the projection of \(S\) to any of the direct sum components
is an element of \(\Hom(S,S^{p})\), which is a
splitting of Frobenius.
Let \(u\) be the projection onto the component of
\(x_{1}^{p-1}, \ldots, x_{n}^{p-1}\).

The splitting \(u\) plays an important role in \(F\)-singularity
theory, see for example 
\cite[Claim~2.6]{ma-polstra-2021-F-sing-comm-alg}.
For our purposes, we are only concerned with computing \(u\) 
for a polynomial in \(S\). 
Given \(f \in S\), we will first compute
\(u(f) \in S^{p}\), and then use the identification
\(S^{p} \isom S\) by taking \(p\)-th roots of 
exponents.

\begin{algorithm}[H]
\caption{Splitting of Frobenius}
\label{alg:naive:u}
\begin{algorithmic}[1]
\State \textbf{Input:} \(f \in S\) 
\State \textbf{Output:} \(u(f)\) considered as an element of \(S\).
\State Discard all terms of \(f\) whose exponents are not congruent to
	\((p-1, \ldots, p-1)\) mod \(p\).
\State result \(\gets 0\)	
\For{\(t \in \text{terms}(f)\) }
    \State subtract \(p-1\) from all exponents of \(t\)
    \State Divide all exponents of \(t\) by \(p\).
    \Comment This division is exact because of the previous step
    \State result \(\gets \text{result} + t\)
\EndFor 
\State \Return result
\end{algorithmic}
\end{algorithm}


\subsection{The Naive Algorithm}

Let \(f\) be a homogeneous polynomial of degree \(n\) 
in \(S\), 
so that \(Z(f)\) is a Calabi-Yau hypersurface.
Following \cite{kty-2022-fedder}, we have the following
algorithm to calculate the quasi-\(F\)-split height.

\begin{algorithm}[H]
\caption{Quasi-\(F\)-Split Height: naive algorithm}
\label{alg:qfs:naive}
\begin{algorithmic}[1]
\State \textbf{Input}: \(b \in \mathbb{N}\) chosen bound, \(f\) a homogeneous
	polynomial of degree \(n\) in \(S\).
\State \textbf{Output:} $h(f)$
\State \(g \gets f^{p-1}\) 
\If{\(g \not\in \mathfrak{m}^{p}\) }
    \State \Return \(1\) 
\EndIf
\State \(\Delta \gets \Delta_{1}(f^{p-1})\) \Comment{Use Algorithm \ref{alg:calc:delta1}}
\State \(h \gets 2\) 
\While{true}
    \If{\(b < h\)}
        \State \Return \(\infty\)
    \EndIf
    \State \(g \gets u(\Delta \cdot g)\) \Comment{Use Algorithm \ref{alg:naive:u}}
    \If{\(g \notin \mathfrak{m}^{p}\)}
        \State \Return \(h\) 
    \EndIf
    \State \(h \gets h + 1\)
\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{thm}
	[\cite{kty-2022-fedder}, Theorem C]
	Assume that
	\(Z(f)\) has quasi-\(F\)-split height \(h < b\).
	Then Algorithm \ref{alg:qfs:naive} terminates
	and returns \(h\).
\end{thm}

\begin{proof}
	This is just rephrasing \cite[Theorem~C]{kty-2022-fedder}.
\end{proof}

In the case of Calabi-Yau hypersurfaces, we have bounds on the height by
\cite{van-der-geer-katsura-2003-calabi-yau},
so we can deterministically recover the height.  
See also \cite[Theorem~0.1]{artin-1974-k3-surfaces},
for the case of K3 surfaces.
For a K3 surface, the height (if finite) is bounded by 10.

\subsection{The key idea: finding the matrix of the linear operator ``multiply then split''}

An implementation of Algorithm \ref{alg:qfs:naive}
is provided in MMPSingularities.jl.
The bottleneck ends up being polynomial multiplication, 
in two places:
\begin{enumerate}[(1)]
    \item raising (a lift of) \(g = f^{p-1}\) to the \(p\)-th power 
        (in line 4 of Algorithm \ref{alg:calc:delta1})
    \item multiplying \(g\) by \(\Delta_{1}(f^{p-1})\) 
        (in line 13 of Algorithm \ref{alg:qfs:naive})
\end{enumerate}

\noindent For a quartic K3 surface of characteristic \(5\),
for example, each step takes about 1 second 
using FLINT \cite{flint-2023-flint}. 

We now explain how to overcome the second
bottleneck. Since \(Z(f)\) is Calabi-Yau
(i.e. \(\deg f = n\)), we have that \(f^{p-1}\) has degree
\(n(p-1)\). 
Furthermore, by Proposition \ref{prop:delta1:formula}
the degree of \(\Delta_{1}(f^{p-1})\) 
is \(np(p - 1)\).
Thus, \(\Delta_{1}(f^{p-1})g\) has degree
\(n(p^{2} - 1)\); however, the effect 
of \(u\) on any polynomial is subtracting \(p-1\)
from the exponents of the terms and dividing by \(p\) 
(see Algorithm \ref{alg:naive:u}).
Thus, the ``multiply then split'' map 
\(g \mapsto u(\Delta_{1}(f^{p-1}) g)\) 
is a linear map from 
the space of homogeneous polynomials of degree \(n(p-1)\) 
to itself.
As a consequence of this observation,
if we can efficiently compute the matrix of 
\(g \mapsto u(\Delta_{1}(f^{p-1})g)\),
we can repeatedly apply matrix-vector multiplication.

Furthermore, when \(g\) is written as a vector 
in the basis of homogeneous monomials of degree
\(n(p-1)\), we can test if \(g \notin \mathfrak{m}^{[p]}\) 
in an especially simple way: the only 
monomial that is not in \(\mathfrak{m}^{[p]}\) is
\(x_{1}^{p-1}\cdots x_{n}^{p-1}\), 
see for example \cite{kty-2022-fedder}.
Thus, we can check if a single element of the vector representing
\(g\) is nonzero.

The algorithm for Fedder's criterion then becomes:

\begin{algorithm}[H]
\caption{Quasi-\(F\)-Split Height: matrix-based algorithm}
\label{alg:qfs:matrix}
\begin{algorithmic}[1]
\State \textbf{Input}: \(b \in \mathbb{N}\) chosen bound, \(f\) a homogeneous
	polynomial of degree \(n\) in \(S\).
\State \textbf{Output:} $h(f)$
\State \(g \gets f^{p-1}\) 
\If{\(g \not\in \mathfrak{m}^{p}\) }
    \State \Return \(1\) 
\EndIf
\State \(\Delta \gets \Delta_{1}(f^{p-1})\) \Comment{Use Algorithm \ref{alg:calc:delta1}}
\State \(M \gets\) the matrix of  \(g^{\prime} \mapsto u(\Delta g^{\prime})\)
\State \(h \gets 2\) 
\State \(g_{v} \gets\) the representation of \(g\) as a vector
\State \(i \gets \) the index of the monomial \(x_{1}^{p-1}\cdots x_{n}^{p-1}\)
\While{true}
    \If{\(b < h\)}
        \State \Return \(\infty\)
    \EndIf
    \State \(g_{v} \gets M g_{v}\) 
    \If{\(g[i] \neq 0\)}
        \State \Return \(h\) 
    \EndIf
    \State \(h \gets h + 1\)
\EndWhile
\end{algorithmic}
\end{algorithm}

Thus, we have reduced our problem (algorithmically, at least)
to finding the matrix of a ``mulitply then split'' operation.
